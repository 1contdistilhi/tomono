#+TITLE:        Tomono — Multi- to Monorepo Migration
#+DESCRIPTION:  Migrate your multirepo to a monorepo using a bash script
#+AUTHOR:       Hraban Luyat
#+EMAIL:        hraban@0brg.net
#+PROPERTY:     header-args       :noweb no-export

#+BEGIN_SRC txt :references lala :exports none
for later:
,#+PROPERTY:     header-args:shell :comments link
#+END_SRC

#+NAME: configure-org-mode-for-this-file
#+BEGIN_SRC emacs-lisp :exports results :results none
  ;; This is configuration for org mode itself, not tomono src code. Don't export this.

  ;; TODO: Don't define as global functions? How do you do this in EL?

  (defun org-info-name (info)
    (nth 4 info))

  (defun insert-ln (&rest args)
    (apply #'insert args)
    (newline))

  (defun should-reference (info)
    "Determine if this info block is a referencing code block"
    (not (memq (alist-get :noweb (nth 2 info))
               '(nil "no"))))

  (defun re-findall (re str &optional offset)
    "Find all matches of a regex in the given string"
    (let ((start (string-match re str offset))
          (end (match-end 0)))
      (when (numberp start)
        (cons (substring str start end) (re-findall re str end)))))

  ;; Match groups are the perfect tool to achieve this but EL's regex is
  ;; inferior and it's not worth the hassle. Blag it manually.

  (defun strip-delimiters (s prefix suffix)
    "Strip a prefix and suffix delimiter, e.g.:
  (strip-delimiters \"<a>\" \"<\" \">\")
  => \"a\"

  Note this function trusts the input string has those delimiters"
    (substring s (length prefix) (- (length suffix))))

  (defun strip-noweb-delimiters (s)
    "Strip the org noweb link delimiters, usually << and >>"
    (strip-delimiters s org-babel-noweb-wrap-start org-babel-noweb-wrap-end))

  (defun extract-refs (body)
    (mapcar #'strip-noweb-delimiters (re-findall (org-babel-noweb-wrap) body)))

  (defun add-to-hash-list (k elem hash)
    "Assuming the hash values are lists, add this element to k's list"
    (puthash k (cons elem (gethash k hash)) hash))

  (defun register-refs (name refs)
    (puthash name refs forward-refs)
    ;; Add a backreference to every ref
    (mapc (lambda (ref)
            (add-to-hash-list ref name back-refs))
          refs))

  (defun parse-blocks ()
    (let ((forward-refs (make-hash-table :test 'equal))
          (back-refs (make-hash-table :test 'equal)))
      (org-babel-map-src-blocks nil
        ;; Probably not v efficient, but should be memoized anyway?
        (let* ((info (org-babel-get-src-block-info full-block))
               (name (org-info-name info)))
          (when (and name (should-reference info))
            (register-refs name (extract-refs body)))))
      (list forward-refs back-refs)))

  (defun insert-reference (ref)
    (insert-ln "- [[" ref "][" ref "]]"))

  (defun insert-references-block (info title refs)
    (when refs
      (message "Formatting references block %S: %S" title refs)
      (insert-ln title)
      (mapc #'insert-reference refs)))

  (defun insert-references (info forward back)
    (when (or forward back)
      (newline)
      (insert-ln ":REFERENCES:")
      (insert-references-block info "References:" forward)
      (insert-references-block info "Used by:" back)
      (insert-ln ":END:")))

  (defun get-references (name)
    (list (gethash name forward-refs) (gethash name back-refs)))

  (defun fix-references (backend)
    "Append a references section to every noweb codeblock"
    (destructuring-bind (forward-refs back-refs) (parse-blocks)
      (message "parsed forward: %S" forward-refs)
      (message "parsed backward: %S" back-refs)
      (org-babel-map-src-blocks nil
        (let ((info (org-babel-get-src-block-info full-block)))
          (message "NOCOMMIT -- should reference %S ? (alist-get :references %S) : %S" (org-info-name info) (nth 2 info) (alist-get :references (nth 2 info)))
          (when (should-reference info)
            (pcase-let ((`(,language ,body ,arguments ,switches ,name ,start ,coderef) info))
              (message "fix-references: Block %S at point %S beg-block %S end-block %S beg-body %S end-body %S, line: %s" name (point) beg-block end-block beg-body end-body (thing-at-point 'line t))
              (goto-char end-block)
              (apply #'insert-references info (get-references name))))))))

  (add-hook 'org-export-before-parsing-hook 'fix-references nil t)
#+END_SRC

#+NAME: debug-org
#+BEGIN_SRC emacs-lisp :exports none :results output
  ;;Debugging org mode. Should also not export

  (defun my-tracing-func (orig-fun &rest args)
    "Debug advice for a function"
    (message "Calling with %S" args)
    (let ((res (apply orig-fun args)))
      (message "returned %S" res)
      res))

  ;(advice-add #'org-babel-exp-code :around #'my-tracing-func)
  ;(advice-remove #'org-babel-exp-code #'my-tracing-func)

  ;(advice-function-mapc (lambda (&rest args) (message "%S" args)) #'foo)
  ;(foo 123)

  ;; (org-babel-map-src-blocks nil
  ;;   (let ((info (org-babel-get-src-block-info full-block)))
  ;;     (pcase-let ((`(,language ,body ,arguments ,switches ,name ,start ,coderef) info))
  ;;       (princ (format "\n===%s===\n" name))
  ;;       (princ "\n## block\n")
  ;;       (pp full-block)
  ;;       (princ "\n## info\n")
  ;;       (pp info))))
#+END_SRC
 
* Motivation

TODO: Explain why you'd wanna do this. Trade-offs, etc.

Further reading: https://syslog.ravelin.com/multi-to-mono-repository-c81d004df3ce

* Implementation

The outer program structure is a flat bash script which loops over every repo supplied over stdin.

#+CAPTION: top-level
#+NAME: top-level
#+BEGIN_SRC shell :tangle tomono :comments link :shebang "#!/usr/bin/env bash" :references ye

<<set-flags>>

<<prep-dir>>

while read repourl reponame; do
    <<handle-remote>>
done

# <<copyright>>
#+END_SRC

:REFERENCES:
References:
- [[copyright][copyright]]
- [[handle-remote][handle-remote]]
- [[prep-dir][prep-dir]]
- [[set-flags][set-flags]]
:END:

** Per repository

Every repository is fetched and fully handled individually, and sequentially. First, fetch all the data related to this repository, then immediately check out and initialise every single branch which belongs to that repository.

#+CAPTION: handle-remote
#+NAME: handle-remote
#+BEGIN_SRC shell :comments link :references yeye
  git remote add "$reponame" "$repourl"
  git fetch --no-tags "$reponame"
  <<list-branches>> | while read branch ; do
      <<handle-branch>>
  done
#+END_SRC

:REFERENCES:
References:
- [[handle-branch][handle-branch]]
- [[list-branches][list-branches]]
Used in:
- [[top-level][top-level]]
:END:

** Per branch

In the context of a single repository check-out, every branch is checked out into a subdir for that repository, and merged into the monorepo.

This is work in progress.

#+CAPTION: handle-branch
#+NAME: handle-branch
#+BEGIN_SRC sh
git checkout --orphan "$branch" && \
    git commit --allow-empty -m "root commit for monorepo branch $branch" || true
git rm -rf .
git checkout --subtree=...
git merge ...
#+END_SRC

** Set up the monorepo directory

We create a fresh directory for this script to run in, and bail if it already exists to avoid mangling an existing repo.

#+CAPTION: prep-dir
#+NAME: prep-dir
#+BEGIN_SRC sh
: "${MONOREPO_NAME:=core}"
if [[ -d "$MONOREPO_NAME" ]]; then
    >&2 echo "monorepo directory $MONOREPO_NAME already exists"
    exit 1
fi

mkdir "$MONOREPO_NAME"
cd "$MONOREPO_NAME"
git init
#+END_SRC

The reason we don't just do this:
#+BEGIN_SRC sh :tangle no :results inline
echo HELLO THERE
date
#+END_SRC

#+RESULTS:
| HELLO | THERE |     |      |          |     |
| Tue   |    24 | Mar | 2020 | 18:33:58 | GMT |

is because that would be crazy.

** List individual branches

I just want a single branch name per line on stdout, for a single
specific remote. Additionally, I want to keep any text manipulation to
a minimum, so as not to expose myself to any weird unicode or
space/tab/special character risk. It turns out that the most reliable
way to do this is not a plumbing command like =git list-raw-branches
my-remote=, but jumping down into the git filesystem database and
reading the raw file names directly.

Execute it all in a subshell to keep the effect of =cd= localised to this block of code.

#+CAPTION: list-branches
#+NAME: list-branches
#+BEGIN_SRC sh
( cd ".git/refs/remotes/$reponame" && find . -type f -mindepth 1 | sed -e s/..// )
#+END_SRC

** Error flags, warnings, debug

Various sh flags allow us to control the behaviour of the shell: treat
any unknown variable reference as an error, treat any non-zero exit
status in a pipeline as an error (instead of only looking at the last
program), and treat any error as fatal and quit. Additionally, if the
=DEBUGSH= environment variable is set, enable "debug" mode by echoing
every command before it gets executed.

#+CAPTION: set-flags
#+NAME: set-flags
#+BEGIN_SRC sh
set -euo pipefail ${DEBUGSH+-x}
#+END_SRC


* Copyright and license

This is a cleanroom reimplementation of the tomono.sh script, originally written with copyright assigned to Ravelin Ltd., a UK fraud detection company. There were some questions around licensing, and it was unclear how to go forward with maintenance of this project given its dispersed copyright, so I went ahead and rewrote the entire thing for a fresh start. The license and copyright attribution of this entire document can now be set:

#+CAPTION: copyright
#+NAME: copyright
#+BEGIN_SRC txt
Copyright © 2020 Hraban Luyat <hraban@0brg.net>
Licensed under the AGPLv3. Details in the License chapter.
#+END_SRC

** GNU AGPLv3 Full License

#+BEGIN_SRC txt :tangle LICENSE :references yeye
NOCOMMIT
#+END_SRC
